name: üöÄ Complete CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
      - '**' 
      # - 'feature/**'
  pull_request:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      force_skip_tests:
        description: 'Force skip all tests'
        required: false
        default: false
        type: boolean
      # deploy_environment:
      #   description: 'Deploy to environment'
      #   required: false
      #   default: 'none'
      #   type: choice
      #   options:
      #     - none
      #     - staging
      #     - production
      # run_performance_tests:
      #   description: 'Run performance tests'
      #   required: false
      #   default: false
      #   type: boolean

# Security permissions (principle of least privilege)
permissions:
  contents: read
  actions: read
  checks: write
  pull-requests: write
  security-events: write
  issues: write

# Global environment variables
env:
  NODE_VERSION: '18'
  YARN_CACHE_FOLDER: ~/.cache/yarn
  FORCE_SKIP_TESTS: ${{ github.event.inputs.force_skip_tests == 'true' || contains(github.event.head_commit.message, '[skip tests]') }}

jobs:
  # =========================================
  # JOB 1: MONOREPO VERSIONING
  # =========================================
  monorepo-versioning:
    name: üì¶ Monorepo Versioning
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      changed-packages: ${{ steps.version.outputs.changed-packages }}
      release-type: ${{ steps.version.outputs.release-type }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: üì¶ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'yarn'

      - name: üìã Generate version and detect changes
        id: version
        run: |
          # Install semver tool
          npm install -g semver
          
          # Get current version from package.json
          if [ -f "package.json" ]; then
            CURRENT_VERSION=$(node -p "require('./package.json').version")
          else
            CURRENT_VERSION="0.0.0"
          fi
          
          # Determine release type based on branch
          BRANCH_NAME="${{ github.ref_name }}"
          if [[ "$BRANCH_NAME" == "main" ]]; then
            RELEASE_TYPE="patch"
          elif [[ "$BRANCH_NAME" == "develop" ]]; then
            RELEASE_TYPE="minor"

          else
            RELEASE_TYPE="prerelease"
          fi
          
          # Generate new version
          NEW_VERSION=$(semver -i $RELEASE_TYPE $CURRENT_VERSION)
          
          # Detect changed packages in monorepo
          CHANGED_PACKAGES="[]"
          if [ -d "packages" ]; then
            CHANGED_PACKAGES=$(find packages -name "package.json" -exec dirname {} \; | jq -R -s -c 'split("\n")[:-1]')
          elif [ -d "apps" ]; then
            CHANGED_PACKAGES=$(find apps -name "package.json" -exec dirname {} \; | jq -R -s -c 'split("\n")[:-1]')
          fi
          
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "changed-packages=$CHANGED_PACKAGES" >> $GITHUB_OUTPUT
          echo "release-type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          
          echo "üì¶ Current Version: $CURRENT_VERSION"
          echo "üÜï New Version: $NEW_VERSION"
          echo "üîÑ Release Type: $RELEASE_TYPE"
          echo "üìÇ Changed Packages: $CHANGED_PACKAGES"

  # =========================================
  # JOB 2: FRONTEND & BACKEND DETECTION
  # =========================================
  detect-services:
    name: Frontend & Backend Detection
    runs-on: ubuntu-latest
    outputs:
      has-frontend: ${{ steps.detect.outputs.has-frontend }}
      has-backend: ${{ steps.detect.outputs.has-backend }}
      frontend-framework: ${{ steps.detect.outputs.frontend-framework }}
      backend-framework: ${{ steps.detect.outputs.backend-framework }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Detect Frontend & Backend
        id: detect
        run: |
          HAS_FRONTEND=false
          HAS_BACKEND=false
          FRONTEND_FRAMEWORK="none"
          BACKEND_FRAMEWORK="none"
          
          # Detect Frontend
          if [ -f "package.json" ]; then
            if grep -q "react" package.json; then
              HAS_FRONTEND=true
              FRONTEND_FRAMEWORK="react"
            elif grep -q "vue" package.json; then
              HAS_FRONTEND=true
              FRONTEND_FRAMEWORK="vue"
            elif grep -q "next" package.json; then
              HAS_FRONTEND=true
              FRONTEND_FRAMEWORK="nextjs"
            fi
          fi
          
          # Detect Backend
          if [ -f "package.json" ]; then
            if grep -q "express" package.json || grep -q "fastify" package.json || grep -q "koa" package.json; then
              HAS_BACKEND=true
              BACKEND_FRAMEWORK="nodejs"
            fi
          fi
          
          echo "has-frontend=$HAS_FRONTEND" >> $GITHUB_OUTPUT
          echo "has-backend=$HAS_BACKEND" >> $GITHUB_OUTPUT
          echo "frontend-framework=$FRONTEND_FRAMEWORK" >> $GITHUB_OUTPUT
          echo "backend-framework=$BACKEND_FRAMEWORK" >> $GITHUB_OUTPUT
          
          echo "Frontend: $HAS_FRONTEND ($FRONTEND_FRAMEWORK)"
          echo "Backend: $HAS_BACKEND ($BACKEND_FRAMEWORK)"

  # =========================================
  # JOB 3: CHANGE DETECTION
  # =========================================
  change-detection:
    name: üîÑ Change Detection
    runs-on: ubuntu-latest
    outputs:
      changed-files: ${{ steps.changes.outputs.changed-files }}
      changed-packages: ${{ steps.changes.outputs.changed-packages }}
      should-test-frontend: ${{ steps.changes.outputs.should-test-frontend }}
      should-test-backend: ${{ steps.changes.outputs.should-test-backend }}
      should-deploy: ${{ steps.changes.outputs.should-deploy }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîÑ Detect changed files
        id: changes
        run: |
          # Get changed files
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }}...${{ github.event.pull_request.head.sha }})
          else
            CHANGED_FILES=$(git diff --name-only HEAD~1..HEAD)
          fi
          
          # Convert to JSON array
          CHANGED_FILES_JSON=$(echo "$CHANGED_FILES" | jq -R -s -c 'split("\n")[:-1]')
          
          # Detect changed packages
          CHANGED_PACKAGES=[]
          if echo "$CHANGED_FILES" | grep -E "^(frontend/|src/|components/|pages/)" > /dev/null; then
            SHOULD_TEST_FRONTEND=true
          else
            SHOULD_TEST_FRONTEND=false
          fi
          
          if echo "$CHANGED_FILES" | grep -E "^(backend/|server/|api/)" > /dev/null; then
            SHOULD_TEST_BACKEND=true
          else
            SHOULD_TEST_BACKEND=false
          fi
          
          # Check if deployment files changed
          if echo "$CHANGED_FILES" | grep -E "(package\.json|yarn\.lock|Dockerfile|docker-compose)" > /dev/null; then
            SHOULD_DEPLOY=true
          else
            SHOULD_DEPLOY=false
          fi
          
          echo "changed-files=$CHANGED_FILES_JSON" >> $GITHUB_OUTPUT
          echo "changed-packages=$CHANGED_PACKAGES" >> $GITHUB_OUTPUT
          echo "should-test-frontend=$SHOULD_TEST_FRONTEND" >> $GITHUB_OUTPUT
          echo "should-test-backend=$SHOULD_TEST_BACKEND" >> $GITHUB_OUTPUT
          echo "should-deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          
          echo "üìÅ Changed Files: $(echo "$CHANGED_FILES" | wc -l) files"
          echo "üé® Test Frontend: $SHOULD_TEST_FRONTEND"
          echo "‚öôÔ∏è Test Backend: $SHOULD_TEST_BACKEND"
          echo "üöÄ Should Deploy: $SHOULD_DEPLOY"

  # =========================================
  # JOB 4: FILE-LEVEL SELECTIVE TESTING
  # =========================================
  selective-testing:
    name: üéØ File-level Selective Testing
    runs-on: ubuntu-latest
    needs: [change-detection]
    outputs:
      test-files: ${{ steps.selective.outputs.test-files }}
      test-suites: ${{ steps.selective.outputs.test-suites }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üéØ Generate selective test list
        id: selective
        run: |
          CHANGED_FILES='${{ needs.change-detection.outputs.changed-files }}'
          TEST_FILES=[]
          TEST_SUITES=[]
          
          # Find corresponding test files for changed files
          echo "$CHANGED_FILES" | jq -r '.[]' | while read file; do
            # Remove extension and find test files
            BASE_NAME=$(echo "$file" | sed 's/\.[^.]*$//')
            
            # Look for test files
            if [ -f "${BASE_NAME}.test.js" ]; then
              TEST_FILES=$(echo "$TEST_FILES" | jq ". + [\"${BASE_NAME}.test.js\"]")
            fi
            
            if [ -f "${BASE_NAME}.test.ts" ]; then
              TEST_FILES=$(echo "$TEST_FILES" | jq ". + [\"${BASE_NAME}.test.ts\"]")
            fi
            
            if [ -f "${BASE_NAME}.spec.js" ]; then
              TEST_FILES=$(echo "$TEST_FILES" | jq ". + [\"${BASE_NAME}.spec.js\"]")
            fi
            
            # Check test directories
            if [ -d "__tests__" ] && find __tests__ -name "*$(basename $BASE_NAME)*" | head -1 | grep -q .; then
              TEST_SUITES=$(echo "$TEST_SUITES" | jq ". + [\"$(basename $BASE_NAME)\"]")
            fi
          done
          
          # If no specific tests found, include all tests
          if [ "$TEST_FILES" = "[]" ]; then
            TEST_FILES=$(find . -name "*.test.*" -o -name "*.spec.*" | jq -R -s -c 'split("\n")[:-1]')
          fi
          
          echo "test-files=$TEST_FILES" >> $GITHUB_OUTPUT
          echo "test-suites=$TEST_SUITES" >> $GITHUB_OUTPUT
          
          echo "üéØ Test Files to Run:"
          echo "$TEST_FILES" | jq .

  # =========================================
  # JOB 5: FILE/FOLDER PUSH TEST TRIGGER
  # =========================================
  test-trigger:
    name: üö¶ Test Trigger Detection
    runs-on: ubuntu-latest
    needs: [change-detection, selective-testing]
    outputs:
      should-run-tests: ${{ steps.trigger.outputs.should-run-tests }}
      test-types: ${{ steps.trigger.outputs.test-types }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üö¶ Determine test trigger
        id: trigger
        run: |
          CHANGED_FILES='${{ needs.change-detection.outputs.changed-files }}'
          SHOULD_RUN_TESTS=false
          TEST_TYPES=[]
          
          # Check if test-related files changed
          if echo "$CHANGED_FILES" | jq -r '.[]' | grep -E "\.(js|ts|jsx|tsx|py|go|rs)$" > /dev/null; then
            SHOULD_RUN_TESTS=true
            TEST_TYPES='["unit", "integration"]'
          fi
          
          # Check if test files themselves changed
          if echo "$CHANGED_FILES" | jq -r '.[]' | grep -E "\.(test|spec)\." > /dev/null; then
            SHOULD_RUN_TESTS=true
          fi
          
          # Check if configuration files changed
          if echo "$CHANGED_FILES" | jq -r '.[]' | grep -E "(jest|vitest|cypress|playwright)\.config" > /dev/null; then
            SHOULD_RUN_TESTS=true
          fi
          
          # Override if forced skip
          if [[ "${{ env.FORCE_SKIP_TESTS }}" == "true" ]]; then
            SHOULD_RUN_TESTS=false
            TEST_TYPES="[]"
          fi
          
          echo "should-run-tests=$SHOULD_RUN_TESTS" >> $GITHUB_OUTPUT
          echo "test-types=$TEST_TYPES" >> $GITHUB_OUTPUT
          
          echo "üö¶ Should Run Tests: $SHOULD_RUN_TESTS"
          echo "üìã Test Types: $TEST_TYPES"

  # =========================================
  # JOB 6: BRANCH BASED TRIGGERING
  # =========================================
  branch-strategy:
    name: üåø Branch-based Strategy
    runs-on: ubuntu-latest
    outputs:
      deploy-environment: ${{ steps.strategy.outputs.deploy-environment }}
      run-security: ${{ steps.strategy.outputs.run-security }}
      run-performance: ${{ steps.strategy.outputs.run-performance }}
      notification-level: ${{ steps.strategy.outputs.notification-level }}
    steps:
      - name: üåø Determine branch strategy
        id: strategy
        run: |
          BRANCH_NAME="${{ github.ref_name }}"
          DEPLOY_ENV="none"
          RUN_SECURITY=false
          RUN_PERFORMANCE=false
          NOTIFICATION_LEVEL="minimal"
          
          case "$BRANCH_NAME" in
            "main")
              DEPLOY_ENV="production"
              RUN_SECURITY=true
              RUN_PERFORMANCE=true
              NOTIFICATION_LEVEL="full"
              ;;
            "develop")
              DEPLOY_ENV="staging"
              RUN_SECURITY=true
              RUN_PERFORMANCE=false
              NOTIFICATION_LEVEL="standard"
              ;;
            #   ;;
            # feature/*)
            #   DEPLOY_ENV="none"
            #   RUN_SECURITY=false
            #   RUN_PERFORMANCE=false
            #   NOTIFICATION_LEVEL="minimal"
            #   ;;
            *)
              DEPLOY_ENV="none"
              RUN_SECURITY=false
              RUN_PERFORMANCE=false
              NOTIFICATION_LEVEL="minimal"
              ;;
          esac
          
          # Override with manual input
          if [[ "${{ github.event.inputs.deploy_environment }}" != "" && "${{ github.event.inputs.deploy_environment }}" != "none" ]]; then
            DEPLOY_ENV="${{ github.event.inputs.deploy_environment }}"
          fi
          
          echo "deploy-environment=$DEPLOY_ENV" >> $GITHUB_OUTPUT
          echo "run-security=$RUN_SECURITY" >> $GITHUB_OUTPUT
          echo "run-performance=$RUN_PERFORMANCE" >> $GITHUB_OUTPUT
          echo "notification-level=$NOTIFICATION_LEVEL" >> $GITHUB_OUTPUT
          
          echo "üåø Branch: $BRANCH_NAME"
          echo "üöÄ Deploy Environment: $DEPLOY_ENV"
          echo "üîí Run Security: $RUN_SECURITY"
          echo "‚ö° Run Performance: $RUN_PERFORMANCE"

  # =========================================
  # JOB 7: TEST CODE DETECTION & EXECUTION
  # =========================================
  test-execution:
    name: üß™ Test Execution
    runs-on: ubuntu-latest
    needs: [test-trigger, selective-testing, branch-strategy]
    if: needs.test-trigger.outputs.should-run-tests == 'true'
    strategy:
      matrix:
        test-type: ${{ fromJSON(needs.test-trigger.outputs.test-types) }}
        node-version: [18, 20]
      fail-fast: false
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üì¶ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'yarn'

      - name: üîß Install dependencies
        run: |
          if [ -f "yarn.lock" ]; then
            yarn install --frozen-lockfile
          elif [ -f "package-lock.json" ]; then
            yarn ci
          else
            yarn install
          fi

      - name: üß™ Run tests
        run: |
          TEST_FILES='${{ needs.selective-testing.outputs.test-files }}'
          TEST_TYPE="${{ matrix.test-type }}"
          
          echo "üß™ Running $TEST_TYPE tests..."
          
          # Detect test framework and run appropriate command
          if [ -f "jest.config.js" ] || grep -q "jest" package.json; then
            if [ "$TEST_TYPE" = "unit" ]; then
              yarn jest --testPathPattern="\.test\." --coverage
            elif [ "$TEST_TYPE" = "integration" ]; then
              yarn jest --testPathPattern="\.integration\." --runInBand
            fi
          elif [ -f "vitest.config.js" ] || grep -q "vitest" package.json; then
            yarn vitest run --reporter=verbose --coverage
          elif grep -q "mocha" package.json; then
            yarn mocha --recursive --reporter spec
          else
            echo "No test framework detected, running generic test command"
            yarn test
          fi
        env:
          CI: true
          NODE_ENV: test

      - name: üìä Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.test-type }}-node-${{ matrix.node-version }}
          path: |
            coverage/
            test-results.xml
            junit.xml
          retention-days: 7

  # =========================================
  # JOB 8: UNTESTED CODE HANDLING
  # =========================================
  untested-code-analysis:
    name: üìä Untested Code Analysis
    runs-on: ubuntu-latest
    needs: [test-execution]
    if: always()
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üì¶ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'yarn'

      - name: üîß Install dependencies
        run: yarn install --frozen-lockfile

      - name: üìä Analyze untested code
        run: |
          echo "üìä Analyzing untested code coverage..."
          
          # Generate coverage report if not exists
          if [ ! -d "coverage" ]; then
            yarn jest --coverage --passWithNoTests || echo "No tests found"
          fi
          
          # Find files without tests
          echo "üîç Files without corresponding test files:"
          find src -name "*.js" -o -name "*.ts" -o -name "*.jsx" -o -name "*.tsx" | while read file; do
            base_name=$(echo "$file" | sed 's/\.[^.]*$//')
            if [ ! -f "${base_name}.test.js" ] && [ ! -f "${base_name}.test.ts" ] && [ ! -f "${base_name}.spec.js" ]; then
              echo "‚ùå $file (no test file found)"
            fi
          done
          
          # Create untested files report
          echo "üìã Generating untested files report..."
          mkdir -p reports
          find src -name "*.js" -o -name "*.ts" | while read file; do
            base_name=$(echo "$file" | sed 's/\.[^.]*$//')
            if [ ! -f "${base_name}.test.js" ] && [ ! -f "${base_name}.test.ts" ]; then
              echo "$file" >> reports/untested-files.txt
            fi
          done

      - name: üìÑ Upload untested code report
        uses: actions/upload-artifact@v4
        with:
          name: untested-code-report
          path: reports/untested-files.txt
          retention-days: 30

  # =========================================
  # JOB 9: LINTING (ESLint/Prettier)
  # =========================================
  linting:
    name: üíÖ Code Quality & Linting
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üì¶ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'yarn'

      - name: üîß Install dependencies
        run: yarn install --frozen-lockfile

      - name: ESLint Check
        run: |
          if [ -f ".eslintrc.js" ] || [ -f ".eslintrc.json" ] || [ -f "eslint.config.js" ]; then
            echo " Running ESLint..."
            yarn lint || npx eslint . --ext .js,.jsx,.ts,.tsx --format=json --output-file=eslint-results.json
          else
            echo " No ESLint config found"
          fi
        continue-on-error: true

      - name: Prettier Check
        run: |
          if [ -f ".prettierrc" ] || [ -f ".prettierrc.json" ] || [ -f "prettier.config.js" ]; then
            echo " Running Prettier..."
            yarn prettier --check . --write || npx prettier --check .
          else
            echo " No Prettier config found"
          fi
        continue-on-error: true

      # - name: üìä TypeScript Check
      #   run: |
      #     if [ -f "tsconfig.json" ]; then
      #       echo "üìä Running TypeScript compiler..."
      #       yarn tsc --noEmit || npx tsc --noEmit
      #     else
      #       echo "‚ö†Ô∏è No TypeScript config found"
      #     fi
      #   continue-on-error: true

      - name: üìÑ Upload lint results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: lint-results
          path: |
            eslint-results.json
            prettier-results.txt
          retention-days: 7

  # =========================================
  # JOB 10: SECURITY SCAN
  # =========================================
  security-scan:
    name: üîí Security Scan
    runs-on: ubuntu-latest
    needs: [branch-strategy]
    if: needs.branch-strategy.outputs.run-security == 'true'
    permissions:
      security-events: write
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üì¶ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: üîí NPM Security Audit
        run: |
          echo "üîí Running npm audit..."
          npm audit --audit-level=moderate --json > npm-audit.json || echo "Vulnerabilities found"
          npm audit --audit-level=moderate || echo "Continuing despite vulnerabilities..."

      - name: üîç Snyk Security Scan
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high --json > snyk-results.json
        continue-on-error: true

      - name: üõ°Ô∏è CodeQL Analysis
        uses: github/codeql-action/init@v3
        with:
          languages: javascript,typescript

      - name: üõ°Ô∏è CodeQL Autobuild
        uses: github/codeql-action/autobuild@v3

      - name: üõ°Ô∏è CodeQL Analysis
        uses: github/codeql-action/analyze@v3

      - name: üìÑ Upload security results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-scan-results
          path: |
            npm-audit.json
            snyk-results.json
          retention-days: 30

  # =========================================
  # JOB 11: CACHE & DEPENDENCIES
  # =========================================
  cache-dependencies:
    name: üóÑÔ∏è Cache & Dependencies Management
    runs-on: ubuntu-latest
    outputs:
      cache-hit: ${{ steps.cache.outputs.cache-hit }}
      cache-key: ${{ steps.cache.outputs.cache-primary-key }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üì¶ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'yarn'

      - name: üóÑÔ∏è Cache node_modules
        id: cache
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            ~/.cache/yarn
            ~/.npm
            .next/cache
            .nuxt
          key: ${{ runner.os }}-deps-${{ hashFiles('**/yarn.lock', '**/package-lock.json') }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-deps-${{ hashFiles('**/yarn.lock', '**/package-lock.json') }}-
            ${{ runner.os }}-deps-

      - name: üîß Install dependencies
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          echo "üíæ Cache miss - Installing fresh dependencies..."
          if [ -f "yarn.lock" ]; then
            yarn install --frozen-lockfile --prefer-offline
          elif [ -f "package-lock.json" ]; then
            npm ci --prefer-offline
          else
            npm install --prefer-offline
          fi

      - name: üíæ Warm up additional caches
        run: |
          # Warm up TypeScript cache
          if [ -f "tsconfig.json" ]; then
            npx tsc --noEmit --incremental
          fi
          
          # Warm up Next.js cache
          if [ -f "next.config.js" ]; then
            npx next build --no-lint || echo "Next.js build warmup completed"
          fi

      - name: üìä Cache statistics
        run: |
          echo "üìä Cache Statistics:"
          echo "Cache Hit: ${{ steps.cache.outputs.cache-hit }}"
          echo "Cache Key: ${{ steps.cache.outputs.cache-primary-key }}"
          echo "Node Modules Size: $(du -sh node_modules 2>/dev/null || echo 'Not found')"

  # =========================================
  # JOB 12: BUILD APPLICATION
  # =========================================
  build:
    name: üèóÔ∏è Build Application
    runs-on: ubuntu-latest
    needs: [cache-dependencies, detect-services, linting]
    strategy:
      matrix:
        environment: [development, staging, production]
        include:
          - environment: development
            build_mode: development
            optimize: false
          - environment: staging
            build_mode: staging
            optimize: true
          - environment: production
            build_mode: production
            optimize: true
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üì¶ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'yarn'

      - name: üóÑÔ∏è Restore dependencies cache
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            ~/.cache/yarn
          key: ${{ needs.cache-dependencies.outputs.cache-key }}

      - name: üîß Install dependencies (if cache miss)
        if: needs.cache-dependencies.outputs.cache-hit != 'true'
        run: yarn install --frozen-lockfile

      - name: üèóÔ∏è Build Frontend
        if: needs.detect-services.outputs.has-frontend == 'true'
        run: |
          echo "üé® Building Frontend (${{ needs.detect-services.outputs.frontend-framework }})..."
          
          case "${{ needs.detect-services.outputs.frontend-framework }}" in
            "react")
              yarn build || npm run build
              ;;
            "nextjs")
              yarn build || npx next build
              ;;
            "vue")
              yarn build || npm run build
              ;;
            "angular")
              yarn build --prod || ng build --prod
              ;;
            "svelte")
              yarn build || npm run build
              ;;
            *)
              yarn build || npm run build
              ;;
          esac
        env:
          NODE_ENV: ${{ matrix.build_mode }}
          OPTIMIZE: ${{ matrix.optimize }}

      - name: üèóÔ∏è Build Backend
        if: needs.detect-services.outputs.has-backend == 'true'
        run: |
          echo "‚öôÔ∏è Building Backend (${{ needs.detect-services.outputs.backend-framework }})..."
          
          case "${{ needs.detect-services.outputs.backend-framework }}" in
            "nodejs")
              if [ -f "tsconfig.json" ]; then
                yarn build || npx tsc
              else
                echo "‚úÖ Node.js project - no build step required"
              fi
              ;;
            "python")
              echo "üêç Python project - installing dependencies..."
              pip install -r requirements.txt
              ;;
            "golang")
              echo "üêπ Building Go application..."
              go build -o app ./...
              ;;
            "rust")
              echo "ü¶Ä Building Rust application..."
              cargo build --release
              ;;
          esac
        env:
          NODE_ENV: ${{ matrix.build_mode }}

      - name: üì¶ Archive build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ matrix.environment }}-${{ github.sha }}
          path: |
            dist/
            build/
            out/
            .next/
            target/release/
            app
          retention-days: 7

      - name: üìä Build size analysis
        run: |
          echo "üìä Build Size Analysis for ${{ matrix.environment }}:"
          if [ -d "dist" ]; then
            echo "Dist folder size: $(du -sh dist)"
            find dist -name "*.js" -exec ls -lh {} \; | head -10
          fi
          if [ -d "build" ]; then
            echo "Build folder size: $(du -sh build)"
          fi

  # =========================================
  # JOB 13: BUNDLE SIZE CHECK
  # =========================================
  # bundle-size-check:
  #   name: üì¶ Bundle Size Analysis
  #   runs-on: ubuntu-latest
  #   needs: [build, detect-services]
  #   if: needs.detect-services.outputs.has-frontend == 'true'
  #   steps:
  #     - name: üì• Checkout code
  #       uses: actions/checkout@v4

  #     - name: üì¶ Download build artifacts
  #       uses: actions/download-artifact@v3
  #       with:
  #         name: build-production-${{ github.sha }}
  #         path: ./build

  #     - name: üìä Analyze bundle size
  #       run: |
  #         echo "üìä Analyzing bundle sizes..."
          
  #         # Install bundle analyzer tools
  #         npm install -g webpack-bundle-analyzer bundlesize

  #         # Analyze different types of builds
  #         if [ -d "build/static" ]; then
  #           echo "üì¶ React/Create React App build detected"
  #           find build/static -name "*.js" -exec ls -lh {} \;
            
  #           # Calculate total JS size
  #           TOTAL_JS_SIZE=$(find build/static -name "*.js" -exec du -b {} \; | awk '{sum+=$1} END {print sum}')
  #           echo "Total JS bundle size: $(echo $TOTAL_JS_SIZE | numfmt --to=iec)"
            
  #           # Check if size is reasonable (< 1MB)
  #           if [ $TOTAL_JS_SIZE -gt 1048576 ]; then
  #             echo "‚ö†Ô∏è Warning: Total JS bundle size exceeds 1MB"
  #           fi
  #         fi
          
  #         if [ -d ".next" ]; then
  #           echo "üì¶ Next.js build detected"
  #           if [ -f ".next/analyze/client.html" ]; then
  #             echo "Bundle analyzer report available"
  #           fi
  #         fi
          
  #         # Create bundle size report
  #         mkdir -p reports
  #         echo "# Bundle Size Report" > reports/bundle-size.md
  #         echo "Generated on: $(date)" >> reports/bundle-size.md
  #         echo "" >> reports/bundle-size.md
          
  #         if [ -d "build" ]; then
  #           echo "## Build Directory Contents" >> reports/bundle-size.md
  #           find build -type f -name "*.js" -o -name "*.css" | while read file; do
  #             size=$(du -h "$file" | cut -f1)
  #             echo "- $file: $size" >> reports/bundle-size.md
  #           done
  #         fi

  #     - name: üîç Bundle size limit check
  #       run: |
  #         # Check if bundlesize config exists
  #         if grep -q "bundlesize" package.json; then
  #           echo "üîç Running bundlesize checks..."
  #           npx bundlesize
  #         else
  #           echo "‚ÑπÔ∏è No bundlesize configuration found"
  #         fi

  #     - name: üìÑ Upload bundle analysis
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: bundle-size-analysis
  #         path: |
  #           reports/bundle-size.md
  #           build/static/**/*.map
  #         retention-days: 14

  #     - name: üí¨ Comment bundle size on PR
  #       if: github.event_name == 'pull_request'
  #       uses: actions/github-script@v7
  #       with:
  #         script: |
  #           const fs = require('fs');
  #           if (fs.existsSync('reports/bundle-size.md')) {
  #             const bundleReport = fs.readFileSync('reports/bundle-size.md', 'utf8');
  #             github.rest.issues.createComment({
  #               issue_number: context.issue.number,
  #               owner: context.repo.owner,
  #               repo: context.repo.repo,
  #               body: `## üì¶ Bundle Size Analysis\n\n${bundleReport}`
  #             });
  #           }

  #   name: üè• Monitoring & Health Check
  #   runs-on: ubuntu-latest
  #   needs: [deploy]
  #   if: needs.deploy.result == 'success'
  #   steps:
  #     - name: üì• Checkout code
  #       uses: actions/checkout@v4

  #     - name: üè• Comprehensive Health Check
  #       run: |
  #         DEPLOY_URL="${{ needs.deploy.outputs.url }}"
  #         echo "üè• Running comprehensive health checks on $DEPLOY_URL..."
          
  #         # Basic health check
  #         echo "1. üîç Basic connectivity check..."
  #         if curl -f -s "$DEPLOY_URL" > /dev/null; then
  #           echo "‚úÖ Basic connectivity: PASSED"
  #         else
  #           echo "‚ùå Basic connectivity: FAILED"
  #           exit 1
  #         fi
          
  #         # API health check
  #         echo "2. üîç API health check..."
  #         if curl -f -s "$DEPLOY_URL/api/health" > /dev/null; then
  #           echo "‚úÖ API health check: PASSED"
  #         else
  #           echo "‚ö†Ô∏è API health check: FAILED (may not exist)"
  #         fi
          
  #         # Response time check
  #         echo "3. ‚è±Ô∏è Response time check..."
  #         RESPONSE_TIME=$(curl -o /dev/null -s -w "%{time_total}" "$DEPLOY_URL")
  #         echo "Response time: ${RESPONSE_TIME}s"
          
  #         if (( $(echo "$RESPONSE_TIME < 2.0" | bc -l) )); then
  #           echo "‚úÖ Response time: PASSED"
  #         else
  #           echo "‚ö†Ô∏è Response time: SLOW (${RESPONSE_TIME}s)"
  #         fi
          
  #         # Status code check
  #         echo "4. üìä HTTP status check..."
  #         STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$DEPLOY_URL")
  #         echo "HTTP Status: $STATUS_CODE"
          
  #         if [ "$STATUS_CODE" -eq 200 ]; then
  #           echo "‚úÖ HTTP Status: PASSED"
  #         else
  #           echo "‚ùå HTTP Status: FAILED ($STATUS_CODE)"
  #         fi

  #     - name: üìä Setup monitoring alerts
  #       run: |
  #         echo "üìä Setting up monitoring alerts..."
          
  #         # Create monitoring configuration
  #         cat > monitoring-config.json << EOF
  #         {
  #           "url": "${{ needs.deploy.outputs.url }}",
  #           "environment": "${{ needs.branch-strategy.outputs.deploy-environment }}",
  #           "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  #           "checks": {
  #             "health": true,
  #             "performance": true,
  #             "security": true
  #           }
  #         }
  #         EOF
          
  #         # Here you would typically send this to your monitoring service
  #         # Example: curl -X POST -H "Content-Type: application/json" -d @monitoring-config.json https://your-monitoring-service.com/api/alerts

  #     - name: üîî Setup uptime monitoring
  #       run: |
  #         echo "üîî Configuring uptime monitoring..."
          
  #         # Example: Setup pingdom/uptime monitoring
  #         # This would typically call your monitoring service API
  #         echo "Uptime monitoring configured for ${{ needs.deploy.outputs.url }}"

  # =========================================
  # JOB 20: NOTIFICATIONS
  # =========================================
  # notifications:
  #   name: üîî Notifications & Reporting
  #   runs-on: ubuntu-latest
  #   needs: [
  #     monorepo-versioning, 
  #     test-execution, 
  #     build, 
  #     # deploy, 
  #     # performance-test, 
  #     security-scan,
  #     branch-strategy
  #   ]
  #   if: always()
  #   steps:
  #     - name: üì• Checkout code
  #       uses: actions/checkout@v4

  #     - name: üìä Generate comprehensive report
  #       run: |
  #         echo "üìä Generating comprehensive CI/CD report..."
          
  #         mkdir -p reports
  #         REPORT_FILE="reports/cicd-report.md"
          
  #         # Generate markdown report
  #         cat > $REPORT_FILE << EOF
  #         # üöÄ CI/CD Pipeline Report
          
  #         **Date**: $(date)
  #         **Branch**: ${{ github.ref_name }}
  #         **Commit**: ${{ github.sha }}
  #         **Triggered by**: ${{ github.event_name }}
          
  #         ## üìã Pipeline Summary
          
  #         | Stage | Status | Duration | Notes |
  #         |-------|--------|----------|--------|
  #         | Versioning | ${{ needs.monorepo-versioning.result }} | - | Version: ${{ needs.monorepo-versioning.outputs.version }} |
  #         | Testing | ${{ needs.test-execution.result }} | - | ${{ needs.test-execution.result == 'skipped' && 'No tests required' || 'Tests completed' }} |
  #         | Build | ${{ needs.build.result }} | - | Multi-environment build |
  #         | Security | ${{ needs.security-scan.result }} | - | Security scan completed |
  #         | Deploy | ${{ needs.deploy.result }} | - | Target: ${{ needs.branch-strategy.outputs.deploy-environment }} |
  #         | Performance | ${{ needs.performance-test.result }} | - | ${{ needs.performance-test.result == 'skipped' && 'Not required for branch' || 'Performance tests completed' }} |
          
  #         ## üéØ Key Metrics
          
  #         - **New Version**: ${{ needs.monorepo-versioning.outputs.version }}
  #         - **Environment**: ${{ needs.branch-strategy.outputs.deploy-environment }}
  #         - **Notification Level**: ${{ needs.branch-strategy.outputs.notification-level }}
          
  #         EOF
          
  #         # Add deployment URL if available
  #         if [ "${{ needs.deploy.outputs.url }}" != "" ]; then
  #           echo "- **Deployment URL**: ${{ needs.deploy.outputs.url }}" >> $REPORT_FILE
  #         fi
          
  #         echo "" >> $REPORT_FILE
  #         echo "## üîç Detailed Results" >> $REPORT_FILE
          
  #         # Add detailed results based on job outcomes
  #         if [ "${{ needs.test-execution.result }}" = "failure" ]; then
  #           echo "‚ùå **Tests Failed**: Some tests did not pass" >> $REPORT_FILE
  #         elif [ "${{ needs.test-execution.result }}" = "success" ]; then
  #           echo "‚úÖ **Tests Passed**: All tests completed successfully" >> $REPORT_FILE
  #         fi
          
  #         if [ "${{ needs.security-scan.result }}" = "failure" ]; then
  #           echo "üîí **Security Issues**: Security vulnerabilities detected" >> $REPORT_FILE
  #         elif [ "${{ needs.security-scan.result }}" = "success" ]; then
  #           echo "‚úÖ **Security**: No critical vulnerabilities found" >> $REPORT_FILE
  #         fi

  #     # - name: üîî Discord Notification
  #     #   if: contains(fromJSON('["full", "standard"]'), needs.branch-strategy.outputs.notification-level)
  #     #   uses: sarisia/actions-status-discord@v1
  #     #   with:
  #     #     webhook: ${{ secrets.DISCORD_WEBHOOK }}
  #     #     title: "üöÄ CI/CD Pipeline Report"
  #     #     description: |
  #     #       **Branch**: ${{ github.ref_name }}
  #     #       **Version**: ${{ needs.monorepo-versioning.outputs.version }}
  #     #       **Environment**: ${{ needs.branch-strategy.outputs.deploy-environment }}
  #     #       **Status**: ${{ job.status }}
  #     #     color: ${{ job.status == 'success' && '3066993' || job.status == 'failure' && '15158332' || '16776960' }}
  #     #     username: "GitHub Actions"
  #     #     avatar_url: "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png"

  #     # - name: üìß Email Notification
  #     #   if: |
  #     #     needs.branch-strategy.outputs.notification-level == 'full' && 
  #     #     (job.status == 'failure' || needs.branch-strategy.outputs.deploy-environment == 'production')
  #     #   uses: dawidd6/action-send-mail@v3
  #     #   with:
  #     #     server_address: smtp.gmail.com
  #     #     server_port: 587
  #     #     username: ${{ secrets.EMAIL_USERNAME }}
  #     #     password: ${{ secrets.EMAIL_PASSWORD }}
  #     #     subject: "üöÄ CI/CD Pipeline Report - ${{ github.repository }}"
  #     #     body: file://reports/cicd-report.md
  #     #     to: ${{ secrets.NOTIFICATION_EMAIL }}
  #     #     from: "GitHub Actions <${{ secrets.EMAIL_USERNAME }}>"
  #     #     content_type: text/markdown

  #     # - name: üì± Slack Notification
  #     #   if: needs.branch-strategy.outputs.notification-level == 'full'
  #     #   uses: 8398a7/action-slack@v3
  #     #   with:
  #     #     status: ${{ job.status }}
  #     #     channel: '#deployments'
  #     #     username: 'GitHub Actions'
  #     #     icon_emoji: ':rocket:'
  #     #     fields: repo,message,commit,author,action,eventName,ref,workflow
  #     #     custom_payload: |
  #     #       {
  #     #         attachments: [{
  #     #           color: '${{ job.status }}' === 'success' ? 'good' : '${{ job.status }}' === 'failure' ? 'danger' : 'warning',
  #     #           blocks: [
  #     #             {
  #     #               type: 'section',
  #     #               text: {
  #     #                 type: 'mrkdwn',
  #     #                 text: `üöÄ *CI/CD Pipeline Report*\n*Repository:* ${{ github.repository }}\n*Branch:* ${{ github.ref_name }}\n*Environment:* ${{ needs.branch-strategy.outputs.deploy-environment }}\n*Status:* ${{ job.status }}`
  #     #               }
  #     #             }
  #     #           ]
  #     #         }]
  #     #       }
  #     #   env:
  #     #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

  #     - name: üìÑ Upload final report
  #       uses: actions/upload-artifact@v4
  #       if: always()
  #       with:
  #         name: cicd-pipeline-report
  #         path: reports/cicd-report.md
  #         retention-days: 90

  #     - name: üìä Update GitHub Status
  #       if: always()
  #       uses: actions/github-script@v7
  #       with:
  #         script: |
  #           const status = '${{ job.status }}' === 'success' ? 'success' : 'failure';
  #           const description = `CI/CD Pipeline ${status} - Version: ${{ needs.monorepo-versioning.outputs.version }}`;
            
  #           github.rest.repos.createCommitStatus({
  #             owner: context.repo.owner,
  #             repo: context.repo.repo,
  #             sha: context.sha,
  #             state: status,
  #             target_url: `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
  #             description: description,
  #             context: 'CI/CD Pipeline'
  #           });

  #     - name: üèÅ Pipeline Summary
  #       run: |
  #         echo "## üöÄ CI/CD Pipeline Completed!" >> $GITHUB_STEP_SUMMARY
  #         echo "" >> $GITHUB_STEP_SUMMARY
  #         echo "### üìä Summary" >> $GITHUB_STEP_SUMMARY
  #         echo "- **Version**: ${{ needs.monorepo-versioning.outputs.version }}" >> $GITHUB_STEP_SUMMARY
  #         echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
  #         echo "- **Environment**: ${{ needs.branch-strategy.outputs.deploy-environment }}" >> $GITHUB_STEP_SUMMARY
  #         echo "- **Pipeline Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          
  #         if [ "${{ needs.deploy.outputs.url }}" != "" ]; then
  #           echo "- **Deployment URL**: ${{ needs.deploy.outputs.url }}" >> $GITHUB_STEP_SUMMARY
  #         fi
          
  #         echo "" >> $GITHUB_STEP_SUMMARY
  #         echo "### üéØ Key Results" >> $GITHUB_STEP_SUMMARY
  #         echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
  #         echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
  #         echo "| Tests | ${{ needs.test-execution.result }} |" >> $GITHUB_STEP_SUMMARY
  #         echo "| Build | ${{ needs.build.result }} |" >> $GITHUB_STEP_SUMMARY
  #         echo "| Security | ${{ needs.security-scan.result }} |" >> $GITHUB_STEP_SUMMARY
  #         echo "| Deploy | ${{ needs.deploy.result }} |" >> $GITHUB_STEP_SUMMARY